---
title: "Interactive graph-based visualization of genome architecture comparisons"
date: 2019-3-2
tags: [visualization, genome, graphs, graph theory, javafx, java]
header:
  image: "/assets/images/DAGGER/dagger_icon.png"
excerpt: "DAGGER, Brouns lab"
---

## Abstract

The variability between genome architectures, the collection of non-random arrangements of functional elements within a genome, can be used to determine the similarities and differences in a genome comparison to study genome evolution. Long-read sequencing brings the benefit of a more accurate assembly in regions of the genome with repetitive sequences and complex structural variation. Long-reads can be more easily aligned to each other which leads to more accurate comparisons of genome architectures. Instead of aligning sequences, a single graph-based data structure can offer more information of similarities and differences in genome architecture in variable regions. Ptolemy is a tool that is able to compare genome architectures without the need of a reference in a gene graph with vertices representing genes. The interpretation of these gene graphs can however be difficult without visualization, and currently few tools provide biological depth when representing these graphs. In this study we present Directed Acyclic Graphs for GEnomic readability (DAGGER), a tool with a graphical user interface for the interactive visualization of gene graphs from GFA1-formatted files. We show the features of DAGGER by visualizing the genome architecture comparison of three novel Escherichia phages (most closely related to vB_EcoM_AYO145A) in a single gene graph using Ptolemy. We also present the stand-alone tool POET (Ptolemy Output Enhancement Tool). This tool can be used for the further analysis of genome graph data generated by Ptolemy. With help of Ptolemy and POET we partially analyse the genome architecture of a dataset of long-sequencing reads of a chimeric generated bacteriophage of E. coli bacteria BL21phi10. Finally, we present a discussion about the advantages and disadvantages of different layout algorithms to visualize gene graphs.


## Contents

- Abstract
- List of abbreviations

1. Introduction
   1. The benefits of long-read sequencing for comparative genomics
   2. The use of gene graphs for comparative genomics
   3. Visualizing gene graphs
   4. Project aim
2. Methods
   1. Development of DAGGER
      1. Sugiyama Layout
      2. Circular Layout
   2. Development of POET
   3. Three novel coliphage dataset
   4. BL21phi10 chimeric phage dataset
3. Results
   1. DAGGER: Visualization of graph-based genome architecture comparisons
   2. POET: Long-read gene graph analysis
   3. Analysis of the three novel coliphage dataset
   4. Analysis of the BL21phi10 chimeric phage datase
4. Discussion
5. Conclusion

- Acknowledgements
- References


## List of abbreviations
BANDAGE	a Bioinformatics Application for Navigating De novo Assembly Graphs Easily

DAGGER	Directed Acyclic Graphs for GEnomic Readability

GFA1		Graphical Fragment Assembly format 1

JUNG		Java Universal Network/Graph framework

POET		Ptolemy Output Enhancement Tool

## 1 Introduction
The first sequencing of a genome (bacteriophage MS2) was reported in 1976 (Fiers et al., 1976). The upcoming of comparative genomics would however be much later, starting with the whole genome sequencing of _Mycoplasma genitalium_ (Fraser et al., 1995) and _Haemophilus influenza_ (Fleischmann et al., 1995). Currently, comparative genomics is widely used when analysing sequenced genomes (Koonin & Galperin, 2013). The field of comparative genomics aims to compare the genetic content of two or more species to identify the similarities and differences between genomes. The totality of non-random arrangements of functional elements in a genome can be described as genome architecture (Koonin, 2009). The study of genome evolution (the process by which a genome changes in structure over time through mutation, horizontal gene transfer and sexual reproduction) compares genome architectures between closely and distantly related genomes. This comparison can indicate the similarities and differences through evolution and lead to findings of how a genome is able to evolve through time.

A sequencing run generates data in the form of reads. A read is an inferred sequence of base pairs of as given molecule. Reads that share an overlap can be assembled into contigs. A contig can be described as a collection of partially or entirely overlapping reads that together represent a consensus sequence of a genetic fragment. The genome assembly can contain multiple contigs, which indicates the presence of a gap. To bridge the gap between these contigs it is needed to create a scaffold (__Figure 1__) (Fierst, 2015; Waterston, Lander, & Sulston, 2002). Outside of these contigs and scaffolds it is also possible to visualize the result of the assembly as a graph. Assembly graphs provide extra layer of information, as it contains connections between reads (Wick, Schultz, Zobel, & Holt, 2015).

<a href="/assets/images/DAGGER/schematic_representation_of_sequence_information.png"><img src="/assets/images/DAGGER/schematic_representation_of_sequence_information.png"></a>
__Figure 1:__ _Schematic representation of sequence information._ Reads that have a partial or complete overlap with another read makes a contig. A contig, a collection of overlapping reads, starts at the lowest base pair position of said reads and ends at the highest base pair positions of said reads. If a single contig does not cover all the reads than there is a need for scaffolds. Adapted from _https://www.biostars.org/p/253222/_.


When comparing genome architectures one of the genomes is selected as a reference genome. Marschall et al. describes that a reference genome can be built up in multiple ways: __(1)__ Getting the genome of one single individual as a reference; __(2)__ a consensus genome of an entire population; __(3)__ use the functional elements of a genome (with mutations); and __(4)__ aligning all sequences ever detected to analyse jointly, defined as an “maximal genome”. The representation of this “maximal genome” in a “pan-genome” instead of a single reference genome proves to contain a more complete set of functional elements to analyse (Marschall et al., 2018). A pan-genome can be defined as the core genome containing all the genes that are found in all strains and a dispensable, accessory genome containing all the genes that are only found in a sub set of strains (Tettelin et al., 2005). This pan-genome creates a collection of reference genomes to be analysed jointly (Marschall et al., 2018). The storage of these collections of genomic sequences into graph-based data structures has proven to improve the analysis of complex genomic regions like the major histocompatibility complex (Dilthey, Cox, Iqbal, Nelson, & McVean, 2015).


### 1.1 The benefits of long-read sequencing for comparative genomics
Most Next Generation Sequencing (NGS) methods, often referred to as high-throughput sequencing, e.g. Illumina, produce a great number of short reads (Fierst, 2015). These short reads have a read length between 100 to 500 base pairs (Jünemann et al., 2013). While the accuracy of genotyping is fairly high with these reads in non-repetitive regions, they cannot provide a contiguous de novo assembly. These short reads are not accurate enough to assemble a genome with repetitive sequences or complex structural variation (Jain et al., 2018).

More recently came the technology of long-read sequencing. Single-molecule real-time sequencers from Pacific Biosciences are able to produce reads of over 10 kilo base pairs long (Gordon et al., 2016). These long reads can greatly help with the assembly of a genome. Although it has been reported that these single-molecule real-time sequencers suffer from significantly higher error rates in the reads compared to shorter read sequencers from Illumina. To create an accurate assembly the use of de novo assembly algorithms and accurate short reads mapping is necessary (Chaisson, Wilson, & Eichler, 2015; Fierst, 2015).

An alternative recently developed technology in sequencing is “pore sequencing”, e.g. nanopore sequencing from Oxford Nanopore Technologies. In this electrochemical method, a nanopore detects single-molecules by electrophoretically driving said molecules in solution (Branton et al., 2008). Recent improvements lead to ultra-long-reads vastly helping in the assembly of complete genomes (Jain et al., 2018). By only using a single sequencing technology (Loman, Quick, & Simpson, 2015), Jain et al. has been able to produce at 30× coverage an human genome assembly with accuracy to 99.44%. Because of this the reconstruction of genomes containing complex structural variation is highly improved, facilitating the comparison of genomic architectures (Jain et al., 2018). Long reads provide a substantial improvement when compared to short reads in assembly contiguity, creating a more accurate assembly.


### 1.2 The use of gene graphs for comparative genomics
A gene graph can be defined as a graph-based data structure that describes the order of genes in a genome. The gene graph is an ordered pair G = (V,E) with the vertex set V representing the genes and the edge set E representing the order of which genes follow each other. Similar to the definition of a computational pan-genome, a gene graph comparing multiple genome architectures also represents a collection of genomic sequences to be analysed (Marschall et al., 2018). The goal of a gene graph is to reduce the reference bias for a more accurate analysis of genome comparisons.

The construction of gene graphs can be done from whole-genome alignments by detecting the relationship in homology between genome sequences. An example of a tool that tackles this graph construction problem is Ptolemy (Salazar & Abeel, 2018). This tool is able to compare genome architectures of multiple microbial assemblies without the need of a reference genome. Ptolemy can be used to study structural variation and pan-genomes from a ‘top-down’ approach, it uses gene annotations instead of DNA sequences (Salazar & Abeel, 2018).

Contrary to this is the ‘bottom-up’ approach that compares genome architectures based on alignments (Angiuoli & Salzberg, 2010). An example of this is NovoGraph, which performs a global pairwise alignment of each contig relative to the reference genome. A global multiple sequence alignment follows to embed the homology between contigs and the reference genome. Finally an acyclic graph-based data structure is computed to connect the contigs at homologous-identical positions (Biederstedt, Oliver, Hansen, Jajoo, Dunn, et al., 2018).

Another graph-based tool for genome comparison is the Variation Graph toolkit (Garrison et al., 2018). This tool benefits most for short-read data and in which known variation is assembled into a graph to align the short-reads against (Garrison et al., 2018).


### 1.3 Visualizing gene graphs
Although tools such as Ptolemy and NovoGraph create the comparison of the genome architectures in a graph-based data structure, they do not provide a visualization. The interpretation of a gene graph purely from a non-visual point of view can be significantly restricted. There is a need for the visualization of these gene graphs to get an overview and understanding of their contents since existing graph toolkits do not support gene graphs based on whole-genome alignments (Biederstedt, Oliver, Hansen, Jajoo, Olson, et al., 2018).

Gephi is an example of a widely used visualization tool for networks and graph-based data structures (et al. M. Bastian, S. Heymann, 2009). However, it’s broad applicability, difficults the understanding of complex biological data sets.

A specific tool created for visualizing de novo assembly graphs is BANDAGE. Here, the vertices of the graph are single assembled contigs. The edges are the connection between these (Wick et al., 2015). Nowadays, BANDAGE is a widely used tool to assess the quality of an assembly that is graph assisted. However, it is not designed to compare genome architectures, as it lacks the ability to represent individual paths, compare multiple genome architectures or analyse pan-genomes.

### 1.4 Project aim
In this study, we aim to build a tool to study graph-based visualization of genome architectures. This tool aims to show Directed Acyclic Graphs for Genomic Readability (DAGGER). DAGGER was specifically developed for Ptolemy, where vertices represent genes in GFA1-formatted files (Li, 2016). Here, we demonstrate the use of DAGGER by the comparison of three novel coliphages. However, DAGGER struggles with bigger datasets (bigger datasets contain more cycles in a graph causing problems with a Sugiyama layout), as visualization is still troublesome. For that we developed Ptolemy Output Enhancement Tool (POET). This standalone tool was intended to datamine Ptolemy, to improve performance of DAGGER. For this, we have used a chimeric phage dataset (long read data) resulting from evolutionary experiments with Escherichia Coli BL21(DE3).


## 2 Methods


### Development of DAGGER
This tool is written in Java 8 with help of the JavaFX GUI toolkit, and uses the Java Universal Network/Graph framework (JUNG) for the in-memory storage and layout of graphs. JUNG was chosen to separate the Application Programming Interface between the layout and visualization algorithms, which allowed full customization when drawing with JavaFX. The use of the GUI toolkit JavaFX instead of Swing in DAGGER was chosen based on the recommendation from Oracle to migrate Java Applets to Java Web Start and JNLP (docs.oracle.com, 2018). JavaFX provides the ability to write the structure of the graphical user interface separate from the logic of the application in FXML, an XML-based language. In DAGGER the visualization of graphs is drawn with primitives on the graphical context of a canvas instead of shapes on a pane to provide better performance when looking at graphs with many edges and/or vertices.

DAGGER takes as input a GFA1-formatted file (Li, 2016) in which the gene graph is build up from all the lines in the file that describe a path of vertices (__Figure 2__). The edges and vertices of all paths are added to a graph implementation of JUNG for in-memory storage and layout algorithms.
